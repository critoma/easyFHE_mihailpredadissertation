# Speech - Dissertation
---
## [Title + Objective]
As the title says, the goal of my dissertation thesis was to create a WebAssembly module that is capable to process encrypted data, making more accesible to the developers. This is done using the concept of fully homomorphic encryption.

## [Introduction]
Nowadays we are surrounded by information and we tend to create ridiculous amounts of data on daily basis. Every day we make 2.5 milion terabytes worth of information and around 9 percent or 225 000 terabytes is private information, private information that needs to be carefully handled, encrypted, processed and decrypted. 

## [Introduction - homomorphic operations]
Homomorphic encryption represents a technique in which encrypted data can be processed, doing matehmetical computations on them, without ever needing to know the corresponsing plaintext.
Homomorphic encryption is not a new concept. It was first introduced by Rvest Shamir and Adlerman RSA ( guys) 
in 1978 by proposing RSA public key encryption algorithm, which was a multiplication homomorphism then it was followed by ElGammal and Pallier encryption schemes.
There are 3 types of homomorphic encryptions:
 - Partially homomorphic encryption - allows only addition or multiplication unlimited number of times
 - Somewhat homomorphic encryption - allows both addition and multiplication with a limited number of times
 - Fully homomorphic encryption - allows both operations unlimited number of times to be applied to encrypted data
 
 
## [Used technologies]

For this project, the used technologies are: 
- node-SEAL and indirectly Microsoft SEAL libraries that implement homomorphic operations;
(Microsoft SEAL and node-SEAL have both MIT license)
- Rust programming language, WebAssembly and Webpack for the Webassembly module creation;
- Typescript for the library that the end user will use;

## [Architecture page 1]
The architecture is comprised of 5 components:
- Native code component
- WebAssembly compiled from Rust component
- JavaScript autogenerated wrapper component
- EasyFHE Typescript library component 
- The end user which can use the library in Webapps or node applications

### Native code 

 Binaries of SEAL library are imported in node-seal via Emscripten, then a bindings.js file is created and uses node-SEAL API creating a bunch of  simplified functions that will be imported into Rust via FFI (Foreign Function Interface).
 
 ### WebAssembly compiled from Rust component
 
 Now in the Rust, the imported functions are wrapped in other functions which are decorated with the macro `#[wasm_bindgen]`. This decoration is crucial because it will generate a mirror representation of the types and values from the Rust environment to the WebAssembly one. After this `wasm-pack` generates WASM module that mirrors all the Rust functions.
 ## JavaScript autogenerated wrapper component
 From here the WASM bundle is processed by `Webpack` and it produces this JavaScript autogenerated wrapper component.
 This is contains only the wasm module and an index.js file that makes import and exporting easier.

### EasyFHE Typescript library component 
Here there is the actual typescript library that used this autogenerated module and creates a simpler and common error free API.

## [Architecture page 2]
This is a overview of how the EasyFHE library is structured:
EasyFHE has 3 separate classes that manage all functions:
- Plain instance - contains all the arithmetic computations that could be done
between plain and ciphertexts like addition, subtraction, multiplication
- Setup instance - manages the keypair generations, as well as the module initialization
- Cipher instance - contains all the arithmetic computations that could be done between ciphertexts 
or methods that can be applied on a single ciphertext like negation or exponentiation

## [Demo]
Here is a brief overview of the playgroud that is available on the github pages

## [Results - Loc]
Here we can see that a developer can write on average 4 time less code, while achieving the same goal 

## [Results - Memory]
On average easyFHE uses slightly less ram memory than node-SEAL, due to Rust, WebAssembly and LLVM optimization

## [Results- Speed]
EasyFHE is on average 3% slower than MIT license - Microsoft SEAL si la node-SEAL

